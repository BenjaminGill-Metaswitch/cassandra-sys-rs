// automatically generated by rust-bindgen

pub type ptrdiff_t = ::libc::c_long;
pub type size_t = ::libc::c_ulong;
pub type wchar_t = ::libc::c_int;
pub type Enum_Unnamed1 = ::libc::c_uint;
pub const cass_false: ::libc::c_uint = 0;
pub const cass_true: ::libc::c_uint = 1;
pub type cass_bool_t = Enum_Unnamed1;
pub type cass_float_t = ::libc::c_float;
pub type cass_double_t = ::libc::c_double;
pub type cass_int8_t = ::libc::c_char;
pub type cass_uint8_t = ::libc::c_uchar;
pub type cass_int16_t = ::libc::c_short;
pub type cass_uint16_t = ::libc::c_ushort;
pub type cass_int32_t = ::libc::c_int;
pub type cass_uint32_t = ::libc::c_uint;
pub type cass_int64_t = ::libc::c_long;
pub type cass_uint64_t = ::libc::c_ulong;
pub type cass_byte_t = cass_uint8_t;
pub type cass_duration_t = cass_uint64_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CassInet_ {
    pub address: [cass_uint8_t; 16usize],
    pub address_length: cass_uint8_t,
}
impl ::std::clone::Clone for Struct_CassInet_ {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_CassInet_ {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CassInet = Struct_CassInet_;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CassUuid_ {
    pub time_and_version: cass_uint64_t,
    pub clock_seq_and_node: cass_uint64_t,
}
impl ::std::clone::Clone for Struct_CassUuid_ {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_CassUuid_ {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CassUuid = Struct_CassUuid_;
pub enum Struct_CassCluster_ { }
pub type CassCluster = Struct_CassCluster_;
pub enum Struct_CassSession_ { }
pub type CassSession = Struct_CassSession_;
pub enum Struct_CassStatement_ { }
pub type CassStatement = Struct_CassStatement_;
pub enum Struct_CassBatch_ { }
pub type CassBatch = Struct_CassBatch_;
pub enum Struct_CassFuture_ { }
pub type CassFuture = Struct_CassFuture_;
pub enum Struct_CassPrepared_ { }
pub type CassPrepared = Struct_CassPrepared_;
pub enum Struct_CassResult_ { }
pub type CassResult = Struct_CassResult_;
pub enum Struct_CassErrorResult_ { }
pub type CassErrorResult = Struct_CassErrorResult_;
pub enum Struct_CassIterator_ { }
pub type CassIterator = Struct_CassIterator_;
pub enum Struct_CassRow_ { }
pub type CassRow = Struct_CassRow_;
pub enum Struct_CassValue_ { }
pub type CassValue = Struct_CassValue_;
pub enum Struct_CassDataType_ { }
pub type CassDataType = Struct_CassDataType_;
pub enum Struct_CassFunctionMeta_ { }
pub type CassFunctionMeta = Struct_CassFunctionMeta_;
pub enum Struct_CassAggregateMeta_ { }
pub type CassAggregateMeta = Struct_CassAggregateMeta_;
pub enum Struct_CassCollection_ { }
pub type CassCollection = Struct_CassCollection_;
pub enum Struct_CassTuple_ { }
pub type CassTuple = Struct_CassTuple_;
pub enum Struct_CassUserType_ { }
pub type CassUserType = Struct_CassUserType_;
pub enum Struct_CassSsl_ { }
pub type CassSsl = Struct_CassSsl_;
pub enum Struct_CassSchemaMeta_ { }
pub type CassSchemaMeta = Struct_CassSchemaMeta_;
pub enum Struct_CassKeyspaceMeta_ { }
pub type CassKeyspaceMeta = Struct_CassKeyspaceMeta_;
pub enum Struct_CassTableMeta_ { }
pub type CassTableMeta = Struct_CassTableMeta_;
pub enum Struct_CassColumnMeta_ { }
pub type CassColumnMeta = Struct_CassColumnMeta_;
pub enum Struct_CassUuidGen_ { }
pub type CassUuidGen = Struct_CassUuidGen_;
pub enum Struct_CassTimestampGen_ { }
pub type CassTimestampGen = Struct_CassTimestampGen_;
pub enum Struct_CassRetryPolicy_ { }
pub type CassRetryPolicy = Struct_CassRetryPolicy_;
pub enum Struct_CassCustomPayload_ { }
pub type CassCustomPayload = Struct_CassCustomPayload_;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CassMetrics_ {
    pub requests: Struct_Unnamed2,
    pub stats: Struct_Unnamed3,
    pub errors: Struct_Unnamed4,
}
impl ::std::clone::Clone for Struct_CassMetrics_ {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_CassMetrics_ {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed2 {
    pub min: cass_uint64_t,
    pub max: cass_uint64_t,
    pub mean: cass_uint64_t,
    pub stddev: cass_uint64_t,
    pub median: cass_uint64_t,
    pub percentile_75th: cass_uint64_t,
    pub percentile_95th: cass_uint64_t,
    pub percentile_98th: cass_uint64_t,
    pub percentile_99th: cass_uint64_t,
    pub percentile_999th: cass_uint64_t,
    pub mean_rate: cass_double_t,
    pub one_minute_rate: cass_double_t,
    pub five_minute_rate: cass_double_t,
    pub fifteen_minute_rate: cass_double_t,
}
impl ::std::clone::Clone for Struct_Unnamed2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed3 {
    pub total_connections: cass_uint64_t,
    pub available_connections: cass_uint64_t,
    pub exceeded_pending_requests_water_mark: cass_uint64_t,
    pub exceeded_write_bytes_water_mark: cass_uint64_t,
}
impl ::std::clone::Clone for Struct_Unnamed3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_Unnamed3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed4 {
    pub connection_timeouts: cass_uint64_t,
    pub pending_request_timeouts: cass_uint64_t,
    pub request_timeouts: cass_uint64_t,
}
impl ::std::clone::Clone for Struct_Unnamed4 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CassMetrics = Struct_CassMetrics_;
pub type Enum_CassConsistency_ = ::libc::c_uint;
pub const CASS_CONSISTENCY_UNKNOWN: ::libc::c_uint = 65535;
pub const CASS_CONSISTENCY_ANY: ::libc::c_uint = 0;
pub const CASS_CONSISTENCY_ONE: ::libc::c_uint = 1;
pub const CASS_CONSISTENCY_TWO: ::libc::c_uint = 2;
pub const CASS_CONSISTENCY_THREE: ::libc::c_uint = 3;
pub const CASS_CONSISTENCY_QUORUM: ::libc::c_uint = 4;
pub const CASS_CONSISTENCY_ALL: ::libc::c_uint = 5;
pub const CASS_CONSISTENCY_LOCAL_QUORUM: ::libc::c_uint = 6;
pub const CASS_CONSISTENCY_EACH_QUORUM: ::libc::c_uint = 7;
pub const CASS_CONSISTENCY_SERIAL: ::libc::c_uint = 8;
pub const CASS_CONSISTENCY_LOCAL_SERIAL: ::libc::c_uint = 9;
pub const CASS_CONSISTENCY_LOCAL_ONE: ::libc::c_uint = 10;
pub type CassConsistency = Enum_CassConsistency_;
pub type Enum_CassWriteType_ = ::libc::c_uint;
pub const CASS_WRITE_TYPE_UKNOWN: ::libc::c_uint = 0;
pub const CASS_WRITE_TYPE_SIMPLE: ::libc::c_uint = 1;
pub const CASS_WRITE_TYPE_BATCH: ::libc::c_uint = 2;
pub const CASS_WRITE_TYPE_UNLOGGED_BATCH: ::libc::c_uint = 3;
pub const CASS_WRITE_TYPE_COUNTER: ::libc::c_uint = 4;
pub const CASS_WRITE_TYPE_BATCH_LOG: ::libc::c_uint = 5;
pub const CASS_WRITE_TYPE_CAS: ::libc::c_uint = 6;
pub type CassWriteType = Enum_CassWriteType_;
pub type Enum_CassValueType_ = ::libc::c_uint;
pub const CASS_VALUE_TYPE_UNKNOWN: ::libc::c_uint = 65535;
pub const CASS_VALUE_TYPE_CUSTOM: ::libc::c_uint = 0;
pub const CASS_VALUE_TYPE_ASCII: ::libc::c_uint = 1;
pub const CASS_VALUE_TYPE_BIGINT: ::libc::c_uint = 2;
pub const CASS_VALUE_TYPE_BLOB: ::libc::c_uint = 3;
pub const CASS_VALUE_TYPE_BOOLEAN: ::libc::c_uint = 4;
pub const CASS_VALUE_TYPE_COUNTER: ::libc::c_uint = 5;
pub const CASS_VALUE_TYPE_DECIMAL: ::libc::c_uint = 6;
pub const CASS_VALUE_TYPE_DOUBLE: ::libc::c_uint = 7;
pub const CASS_VALUE_TYPE_FLOAT: ::libc::c_uint = 8;
pub const CASS_VALUE_TYPE_INT: ::libc::c_uint = 9;
pub const CASS_VALUE_TYPE_TEXT: ::libc::c_uint = 10;
pub const CASS_VALUE_TYPE_TIMESTAMP: ::libc::c_uint = 11;
pub const CASS_VALUE_TYPE_UUID: ::libc::c_uint = 12;
pub const CASS_VALUE_TYPE_VARCHAR: ::libc::c_uint = 13;
pub const CASS_VALUE_TYPE_VARINT: ::libc::c_uint = 14;
pub const CASS_VALUE_TYPE_TIMEUUID: ::libc::c_uint = 15;
pub const CASS_VALUE_TYPE_INET: ::libc::c_uint = 16;
pub const CASS_VALUE_TYPE_DATE: ::libc::c_uint = 17;
pub const CASS_VALUE_TYPE_TIME: ::libc::c_uint = 18;
pub const CASS_VALUE_TYPE_SMALL_INT: ::libc::c_uint = 19;
pub const CASS_VALUE_TYPE_TINY_INT: ::libc::c_uint = 20;
pub const CASS_VALUE_TYPE_LIST: ::libc::c_uint = 32;
pub const CASS_VALUE_TYPE_MAP: ::libc::c_uint = 33;
pub const CASS_VALUE_TYPE_SET: ::libc::c_uint = 34;
pub const CASS_VALUE_TYPE_UDT: ::libc::c_uint = 48;
pub const CASS_VALUE_TYPE_TUPLE: ::libc::c_uint = 49;
pub const CASS_VALUE_TYPE_LAST_ENTRY: ::libc::c_uint = 50;
pub type CassValueType = Enum_CassValueType_;
pub type Enum_CassCollectionType_ = ::libc::c_uint;
pub const CASS_COLLECTION_TYPE_LIST: ::libc::c_uint = 32;
pub const CASS_COLLECTION_TYPE_MAP: ::libc::c_uint = 33;
pub const CASS_COLLECTION_TYPE_SET: ::libc::c_uint = 34;
pub type CassCollectionType = Enum_CassCollectionType_;
pub type Enum_CassBatchType_ = ::libc::c_uint;
pub const CASS_BATCH_TYPE_LOGGED: ::libc::c_uint = 0;
pub const CASS_BATCH_TYPE_UNLOGGED: ::libc::c_uint = 1;
pub const CASS_BATCH_TYPE_COUNTER: ::libc::c_uint = 2;
pub type CassBatchType = Enum_CassBatchType_;
pub type Enum_CassIteratorType_ = ::libc::c_uint;
pub const CASS_ITERATOR_TYPE_RESULT: ::libc::c_uint = 0;
pub const CASS_ITERATOR_TYPE_ROW: ::libc::c_uint = 1;
pub const CASS_ITERATOR_TYPE_COLLECTION: ::libc::c_uint = 2;
pub const CASS_ITERATOR_TYPE_MAP: ::libc::c_uint = 3;
pub const CASS_ITERATOR_TYPE_TUPLE: ::libc::c_uint = 4;
pub const CASS_ITERATOR_TYPE_USER_TYPE_FIELD: ::libc::c_uint = 5;
pub const CASS_ITERATOR_TYPE_META_FIELD: ::libc::c_uint = 6;
pub const CASS_ITERATOR_TYPE_KEYSPACE_META: ::libc::c_uint = 7;
pub const CASS_ITERATOR_TYPE_TABLE_META: ::libc::c_uint = 8;
pub const CASS_ITERATOR_TYPE_TYPE_META: ::libc::c_uint = 9;
pub const CASS_ITERATOR_TYPE_FUNCTION_META: ::libc::c_uint = 10;
pub const CASS_ITERATOR_TYPE_AGGREGATE_META: ::libc::c_uint = 11;
pub const CASS_ITERATOR_TYPE_COLUMN_META: ::libc::c_uint = 12;
pub type CassIteratorType = Enum_CassIteratorType_;
pub type Enum_CassLogLevel_ = ::libc::c_uint;
pub const CASS_LOG_DISABLED: ::libc::c_uint = 0;
pub const CASS_LOG_CRITICAL: ::libc::c_uint = 1;
pub const CASS_LOG_ERROR: ::libc::c_uint = 2;
pub const CASS_LOG_WARN: ::libc::c_uint = 3;
pub const CASS_LOG_INFO: ::libc::c_uint = 4;
pub const CASS_LOG_DEBUG: ::libc::c_uint = 5;
pub const CASS_LOG_TRACE: ::libc::c_uint = 6;
pub const CASS_LOG_LAST_ENTRY: ::libc::c_uint = 7;
pub type CassLogLevel = Enum_CassLogLevel_;
pub type Enum_CassSslVerifyFlags = ::libc::c_uint;
pub const CASS_SSL_VERIFY_NONE: ::libc::c_uint = 0;
pub const CASS_SSL_VERIFY_PEER_CERT: ::libc::c_uint = 1;
pub const CASS_SSL_VERIFY_PEER_IDENTITY: ::libc::c_uint = 2;
pub type CassSslVerifyFlags = Enum_CassSslVerifyFlags;
pub type Enum_CassColumnType_ = ::libc::c_uint;
pub const CASS_COLUMN_TYPE_REGULAR: ::libc::c_uint = 0;
pub const CASS_COLUMN_TYPE_PARTITION_KEY: ::libc::c_uint = 1;
pub const CASS_COLUMN_TYPE_CLUSTERING_KEY: ::libc::c_uint = 2;
pub const CASS_COLUMN_TYPE_STATIC: ::libc::c_uint = 3;
pub const CASS_COLUMN_TYPE_COMPACT_VALUE: ::libc::c_uint = 4;
pub type CassColumnType = Enum_CassColumnType_;
pub type Enum_CassErrorSource_ = ::libc::c_uint;
pub const CASS_ERROR_SOURCE_NONE: ::libc::c_uint = 0;
pub const CASS_ERROR_SOURCE_LIB: ::libc::c_uint = 1;
pub const CASS_ERROR_SOURCE_SERVER: ::libc::c_uint = 2;
pub const CASS_ERROR_SOURCE_SSL: ::libc::c_uint = 3;
pub const CASS_ERROR_SOURCE_COMPRESSION: ::libc::c_uint = 4;
pub type CassErrorSource = Enum_CassErrorSource_;
pub type Enum_CassError_ = ::libc::c_uint;
pub const CASS_OK: ::libc::c_uint = 0;
pub const CASS_ERROR_LIB_BAD_PARAMS: ::libc::c_uint = 16777217;
pub const CASS_ERROR_LIB_NO_STREAMS: ::libc::c_uint = 16777218;
pub const CASS_ERROR_LIB_UNABLE_TO_INIT: ::libc::c_uint = 16777219;
pub const CASS_ERROR_LIB_MESSAGE_ENCODE: ::libc::c_uint = 16777220;
pub const CASS_ERROR_LIB_HOST_RESOLUTION: ::libc::c_uint = 16777221;
pub const CASS_ERROR_LIB_UNEXPECTED_RESPONSE: ::libc::c_uint = 16777222;
pub const CASS_ERROR_LIB_REQUEST_QUEUE_FULL: ::libc::c_uint = 16777223;
pub const CASS_ERROR_LIB_NO_AVAILABLE_IO_THREAD: ::libc::c_uint = 16777224;
pub const CASS_ERROR_LIB_WRITE_ERROR: ::libc::c_uint = 16777225;
pub const CASS_ERROR_LIB_NO_HOSTS_AVAILABLE: ::libc::c_uint = 16777226;
pub const CASS_ERROR_LIB_INDEX_OUT_OF_BOUNDS: ::libc::c_uint = 16777227;
pub const CASS_ERROR_LIB_INVALID_ITEM_COUNT: ::libc::c_uint = 16777228;
pub const CASS_ERROR_LIB_INVALID_VALUE_TYPE: ::libc::c_uint = 16777229;
pub const CASS_ERROR_LIB_REQUEST_TIMED_OUT: ::libc::c_uint = 16777230;
pub const CASS_ERROR_LIB_UNABLE_TO_SET_KEYSPACE: ::libc::c_uint = 16777231;
pub const CASS_ERROR_LIB_CALLBACK_ALREADY_SET: ::libc::c_uint = 16777232;
pub const CASS_ERROR_LIB_INVALID_STATEMENT_TYPE: ::libc::c_uint = 16777233;
pub const CASS_ERROR_LIB_NAME_DOES_NOT_EXIST: ::libc::c_uint = 16777234;
pub const CASS_ERROR_LIB_UNABLE_TO_DETERMINE_PROTOCOL: ::libc::c_uint = 16777235;
pub const CASS_ERROR_LIB_NULL_VALUE: ::libc::c_uint = 16777236;
pub const CASS_ERROR_LIB_NOT_IMPLEMENTED: ::libc::c_uint = 16777237;
pub const CASS_ERROR_LIB_UNABLE_TO_CONNECT: ::libc::c_uint = 16777238;
pub const CASS_ERROR_LIB_UNABLE_TO_CLOSE: ::libc::c_uint = 16777239;
pub const CASS_ERROR_LIB_NO_PAGING_STATE: ::libc::c_uint = 16777240;
pub const CASS_ERROR_LIB_PARAMETER_UNSET: ::libc::c_uint = 16777241;
pub const CASS_ERROR_LIB_INVALID_ERROR_RESULT_TYPE: ::libc::c_uint = 16777242;
pub const CASS_ERROR_LIB_INVALID_FUTURE_TYPE: ::libc::c_uint = 16777243;
pub const CASS_ERROR_SERVER_SERVER_ERROR: ::libc::c_uint = 33554432;
pub const CASS_ERROR_SERVER_PROTOCOL_ERROR: ::libc::c_uint = 33554442;
pub const CASS_ERROR_SERVER_BAD_CREDENTIALS: ::libc::c_uint = 33554688;
pub const CASS_ERROR_SERVER_UNAVAILABLE: ::libc::c_uint = 33558528;
pub const CASS_ERROR_SERVER_OVERLOADED: ::libc::c_uint = 33558529;
pub const CASS_ERROR_SERVER_IS_BOOTSTRAPPING: ::libc::c_uint = 33558530;
pub const CASS_ERROR_SERVER_TRUNCATE_ERROR: ::libc::c_uint = 33558531;
pub const CASS_ERROR_SERVER_WRITE_TIMEOUT: ::libc::c_uint = 33558784;
pub const CASS_ERROR_SERVER_READ_TIMEOUT: ::libc::c_uint = 33559040;
pub const CASS_ERROR_SERVER_READ_FAILURE: ::libc::c_uint = 33559296;
pub const CASS_ERROR_SERVER_FUNCTION_FAILURE: ::libc::c_uint = 33559552;
pub const CASS_ERROR_SERVER_WRITE_FAILURE: ::libc::c_uint = 33559808;
pub const CASS_ERROR_SERVER_SYNTAX_ERROR: ::libc::c_uint = 33562624;
pub const CASS_ERROR_SERVER_UNAUTHORIZED: ::libc::c_uint = 33562880;
pub const CASS_ERROR_SERVER_INVALID_QUERY: ::libc::c_uint = 33563136;
pub const CASS_ERROR_SERVER_CONFIG_ERROR: ::libc::c_uint = 33563392;
pub const CASS_ERROR_SERVER_ALREADY_EXISTS: ::libc::c_uint = 33563648;
pub const CASS_ERROR_SERVER_UNPREPARED: ::libc::c_uint = 33563904;
pub const CASS_ERROR_SSL_INVALID_CERT: ::libc::c_uint = 50331649;
pub const CASS_ERROR_SSL_INVALID_PRIVATE_KEY: ::libc::c_uint = 50331650;
pub const CASS_ERROR_SSL_NO_PEER_CERT: ::libc::c_uint = 50331651;
pub const CASS_ERROR_SSL_INVALID_PEER_CERT: ::libc::c_uint = 50331652;
pub const CASS_ERROR_SSL_IDENTITY_MISMATCH: ::libc::c_uint = 50331653;
pub const CASS_ERROR_SSL_PROTOCOL_ERROR: ::libc::c_uint = 50331654;
pub const CASS_ERROR_LAST_ENTRY: ::libc::c_uint = 50331655;
pub type CassError = Enum_CassError_;
pub type CassFutureCallback = ::std::option::Option<extern "C" fn(future: *mut CassFuture, data: *mut ::libc::c_void) -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CassLogMessage_ {
    pub time_ms: cass_uint64_t,
    pub severity: CassLogLevel,
    pub file: *const ::libc::c_char,
    pub line: ::libc::c_int,
    pub function: *const ::libc::c_char,
    pub message: [::libc::c_char; 256usize],
}
impl ::std::clone::Clone for Struct_CassLogMessage_ {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for Struct_CassLogMessage_ {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CassLogMessage = Struct_CassLogMessage_;
pub type CassLogCallback = ::std::option::Option<extern "C" fn(message: *const CassLogMessage, data: *mut ::libc::c_void) -> ()>;
extern "C" {
    pub fn cass_cluster_new() -> *mut CassCluster;
    pub fn cass_cluster_free(cluster: *mut CassCluster) -> ();
    pub fn cass_cluster_set_contact_points(cluster: *mut CassCluster, contact_points: *const ::libc::c_char) -> CassError;
    pub fn cass_cluster_set_contact_points_n(cluster: *mut CassCluster, contact_points: *const ::libc::c_char, contact_points_length: size_t) -> CassError;
    pub fn cass_cluster_set_port(cluster: *mut CassCluster, port: ::libc::c_int) -> CassError;
    pub fn cass_cluster_set_ssl(cluster: *mut CassCluster, ssl: *mut CassSsl) -> ();
    pub fn cass_cluster_set_protocol_version(cluster: *mut CassCluster, protocol_version: ::libc::c_int) -> CassError;
    pub fn cass_cluster_set_num_threads_io(cluster: *mut CassCluster, num_threads: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_queue_size_io(cluster: *mut CassCluster, queue_size: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_queue_size_event(cluster: *mut CassCluster, queue_size: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_queue_size_log(cluster: *mut CassCluster, queue_size: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_core_connections_per_host(cluster: *mut CassCluster, num_connections: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_max_connections_per_host(cluster: *mut CassCluster, num_connections: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_reconnect_wait_time(cluster: *mut CassCluster, wait_time: ::libc::c_uint) -> ();
    pub fn cass_cluster_set_max_concurrent_creation(cluster: *mut CassCluster, num_connections: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_max_concurrent_requests_threshold(cluster: *mut CassCluster, num_requests: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_max_requests_per_flush(cluster: *mut CassCluster, num_requests: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_write_bytes_high_water_mark(cluster: *mut CassCluster, num_bytes: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_write_bytes_low_water_mark(cluster: *mut CassCluster, num_bytes: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_pending_requests_high_water_mark(cluster: *mut CassCluster, num_requests: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_pending_requests_low_water_mark(cluster: *mut CassCluster, num_requests: ::libc::c_uint) -> CassError;
    pub fn cass_cluster_set_connect_timeout(cluster: *mut CassCluster, timeout_ms: ::libc::c_uint) -> ();
    pub fn cass_cluster_set_request_timeout(cluster: *mut CassCluster, timeout_ms: ::libc::c_uint) -> ();
    pub fn cass_cluster_set_credentials(cluster: *mut CassCluster, username: *const ::libc::c_char, password: *const ::libc::c_char) -> ();
    pub fn cass_cluster_set_credentials_n(cluster: *mut CassCluster, username: *const ::libc::c_char, username_length: size_t, password: *const ::libc::c_char, password_length: size_t) -> ();
    pub fn cass_cluster_set_load_balance_round_robin(cluster: *mut CassCluster) -> ();
    pub fn cass_cluster_set_load_balance_dc_aware(cluster: *mut CassCluster, local_dc: *const ::libc::c_char, used_hosts_per_remote_dc: ::libc::c_uint, allow_remote_dcs_for_local_cl: cass_bool_t) -> CassError;
    pub fn cass_cluster_set_load_balance_dc_aware_n(cluster: *mut CassCluster, local_dc: *const ::libc::c_char, local_dc_length: size_t, used_hosts_per_remote_dc: ::libc::c_uint, allow_remote_dcs_for_local_cl: cass_bool_t) -> CassError;
    pub fn cass_cluster_set_token_aware_routing(cluster: *mut CassCluster, enabled: cass_bool_t) -> ();
    pub fn cass_cluster_set_latency_aware_routing(cluster: *mut CassCluster, enabled: cass_bool_t) -> ();
    pub fn cass_cluster_set_latency_aware_routing_settings(cluster: *mut CassCluster, exclusion_threshold: cass_double_t, scale_ms: cass_uint64_t, retry_period_ms: cass_uint64_t, update_rate_ms: cass_uint64_t, min_measured: cass_uint64_t) -> ();
    pub fn cass_cluster_set_whitelist_filtering(cluster: *mut CassCluster, hosts: *const ::libc::c_char) -> ();
    pub fn cass_cluster_set_whitelist_filtering_n(cluster: *mut CassCluster, hosts: *const ::libc::c_char, hosts_length: size_t) -> ();
    pub fn cass_cluster_set_tcp_nodelay(cluster: *mut CassCluster, enabled: cass_bool_t) -> ();
    pub fn cass_cluster_set_tcp_keepalive(cluster: *mut CassCluster, enabled: cass_bool_t, delay_secs: ::libc::c_uint) -> ();
    pub fn cass_cluster_set_timestamp_gen(cluster: *mut CassCluster, timestamp_gen: *mut CassTimestampGen) -> ();
    pub fn cass_cluster_set_connection_heartbeat_interval(cluster: *mut CassCluster, interval_secs: ::libc::c_uint) -> ();
    pub fn cass_cluster_set_connection_idle_timeout(cluster: *mut CassCluster, timeout_secs: ::libc::c_uint) -> ();
    pub fn cass_cluster_set_retry_policy(cluster: *mut CassCluster, retry_policy: *mut CassRetryPolicy) -> ();
    pub fn cass_cluster_set_use_schema(cluster: *mut CassCluster, enabled: cass_bool_t) -> ();
    pub fn cass_session_new() -> *mut CassSession;
    pub fn cass_session_free(session: *mut CassSession) -> ();
    pub fn cass_session_connect(session: *mut CassSession, cluster: *const CassCluster) -> *mut CassFuture;
    pub fn cass_session_connect_keyspace(session: *mut CassSession, cluster: *const CassCluster, keyspace: *const ::libc::c_char) -> *mut CassFuture;
    pub fn cass_session_connect_keyspace_n(session: *mut CassSession, cluster: *const CassCluster, keyspace: *const ::libc::c_char, keyspace_length: size_t) -> *mut CassFuture;
    pub fn cass_session_close(session: *mut CassSession) -> *mut CassFuture;
    pub fn cass_session_prepare(session: *mut CassSession, query: *const ::libc::c_char) -> *mut CassFuture;
    pub fn cass_session_prepare_n(session: *mut CassSession, query: *const ::libc::c_char, query_length: size_t) -> *mut CassFuture;
    pub fn cass_session_execute(session: *mut CassSession, statement: *const CassStatement) -> *mut CassFuture;
    pub fn cass_session_execute_batch(session: *mut CassSession, batch: *const CassBatch) -> *mut CassFuture;
    pub fn cass_session_get_schema_meta(session: *const CassSession) -> *const CassSchemaMeta;
    pub fn cass_session_get_metrics(session: *const CassSession, output: *mut CassMetrics) -> ();
    pub fn cass_schema_meta_free(schema_meta: *const CassSchemaMeta) -> ();
    pub fn cass_schema_meta_snapshot_version(schema_meta: *const CassSchemaMeta) -> cass_uint32_t;
    pub fn cass_schema_meta_keyspace_by_name(schema_meta: *const CassSchemaMeta, keyspace: *const ::libc::c_char) -> *const CassKeyspaceMeta;
    pub fn cass_schema_meta_keyspace_by_name_n(schema_meta: *const CassSchemaMeta, keyspace: *const ::libc::c_char, keyspace_length: size_t) -> *const CassKeyspaceMeta;
    pub fn cass_keyspace_meta_table_by_name(keyspace_meta: *const CassKeyspaceMeta, table: *const ::libc::c_char) -> *const CassTableMeta;
    pub fn cass_keyspace_meta_table_by_name_n(keyspace_meta: *const CassKeyspaceMeta, table: *const ::libc::c_char, table_length: size_t) -> *const CassTableMeta;
    pub fn cass_keyspace_meta_user_type_by_name(keyspace_meta: *const CassKeyspaceMeta, _type: *const ::libc::c_char) -> *const CassDataType;
    pub fn cass_keyspace_meta_user_type_by_name_n(keyspace_meta: *const CassKeyspaceMeta, _type: *const ::libc::c_char, type_length: size_t) -> *const CassDataType;
    pub fn cass_keyspace_meta_function_by_name(keyspace_meta: *const CassKeyspaceMeta, name: *const ::libc::c_char, arguments: *const ::libc::c_char) -> *const CassFunctionMeta;
    pub fn cass_keyspace_meta_function_by_name_n(keyspace_meta: *const CassKeyspaceMeta, name: *const ::libc::c_char, name_length: size_t, arguments: *const ::libc::c_char, arguments_length: size_t) -> *const CassFunctionMeta;
    pub fn cass_keyspace_meta_aggregate_by_name(keyspace_meta: *const CassKeyspaceMeta, name: *const ::libc::c_char, arguments: *const ::libc::c_char) -> *const CassAggregateMeta;
    pub fn cass_keyspace_meta_aggregate_by_name_n(keyspace_meta: *const CassKeyspaceMeta, name: *const ::libc::c_char, name_length: size_t, arguments: *const ::libc::c_char, arguments_length: size_t) -> *const CassAggregateMeta;
    pub fn cass_keyspace_meta_name(keyspace_meta: *const CassKeyspaceMeta, name: *mut *const ::libc::c_char, name_length: *mut size_t) -> ();
    pub fn cass_keyspace_meta_field_by_name(keyspace_meta: *const CassKeyspaceMeta, name: *const ::libc::c_char) -> *const CassValue;
    pub fn cass_keyspace_meta_field_by_name_n(keyspace_meta: *const CassKeyspaceMeta, name: *const ::libc::c_char, name_length: size_t) -> *const CassValue;
    pub fn cass_table_meta_column_by_name(table_meta: *const CassTableMeta, column: *const ::libc::c_char) -> *const CassColumnMeta;
    pub fn cass_table_meta_column_by_name_n(table_meta: *const CassTableMeta, column: *const ::libc::c_char, column_length: size_t) -> *const CassColumnMeta;
    pub fn cass_table_meta_name(table_meta: *const CassTableMeta, name: *mut *const ::libc::c_char, name_length: *mut size_t) -> ();
    pub fn cass_table_meta_column_count(table_meta: *const CassTableMeta) -> size_t;
    pub fn cass_table_meta_column(table_meta: *const CassTableMeta, index: size_t) -> *const CassColumnMeta;
    pub fn cass_table_meta_partition_key_count(table_meta: *const CassTableMeta) -> size_t;
    pub fn cass_table_meta_partition_key(table_meta: *const CassTableMeta, index: size_t) -> *const CassColumnMeta;
    pub fn cass_table_meta_clustering_key_count(table_meta: *const CassTableMeta) -> size_t;
    pub fn cass_table_meta_clustering_key(table_meta: *const CassTableMeta, index: size_t) -> *const CassColumnMeta;
    pub fn cass_table_meta_field_by_name(table_meta: *const CassTableMeta, name: *const ::libc::c_char) -> *const CassValue;
    pub fn cass_table_meta_field_by_name_n(table_meta: *const CassTableMeta, name: *const ::libc::c_char, name_length: size_t) -> *const CassValue;
    pub fn cass_column_meta_name(column_meta: *const CassColumnMeta, name: *mut *const ::libc::c_char, name_length: *mut size_t) -> ();
    pub fn cass_column_meta_type(column_meta: *const CassColumnMeta) -> CassColumnType;
    pub fn cass_column_meta_data_type(column_meta: *const CassColumnMeta) -> *const CassDataType;
    pub fn cass_column_meta_field_by_name(column_meta: *const CassColumnMeta, name: *const ::libc::c_char) -> *const CassValue;
    pub fn cass_column_meta_field_by_name_n(column_meta: *const CassColumnMeta, name: *const ::libc::c_char, name_length: size_t) -> *const CassValue;
    pub fn cass_function_meta_name(function_meta: *const CassFunctionMeta, name: *mut *const ::libc::c_char, name_length: *mut size_t) -> ();
    pub fn cass_function_meta_full_name(function_meta: *const CassFunctionMeta, full_name: *mut *const ::libc::c_char, full_name_length: *mut size_t) -> ();
    pub fn cass_function_meta_body(function_meta: *const CassFunctionMeta, body: *mut *const ::libc::c_char, body_length: *mut size_t) -> ();
    pub fn cass_function_meta_language(function_meta: *const CassFunctionMeta, language: *mut *const ::libc::c_char, language_length: *mut size_t) -> ();
    pub fn cass_function_meta_called_on_null_input(function_meta: *const CassFunctionMeta) -> cass_bool_t;
    pub fn cass_function_meta_argument_count(function_meta: *const CassFunctionMeta) -> size_t;
    pub fn cass_function_meta_argument(function_meta: *const CassFunctionMeta, index: size_t, name: *mut *const ::libc::c_char, name_length: *mut size_t, _type: *mut *const CassDataType) -> CassError;
    pub fn cass_function_meta_argument_type_by_name(function_meta: *const CassFunctionMeta, name: *const ::libc::c_char) -> *const CassDataType;
    pub fn cass_function_meta_argument_type_by_name_n(function_meta: *const CassFunctionMeta, name: *const ::libc::c_char, name_length: size_t) -> *const CassDataType;
    pub fn cass_function_meta_return_type(function_meta: *const CassFunctionMeta) -> *const CassDataType;
    pub fn cass_function_meta_field_by_name(function_meta: *const CassFunctionMeta, name: *const ::libc::c_char) -> *const CassValue;
    pub fn cass_function_meta_field_by_name_n(function_meta: *const CassFunctionMeta, name: *const ::libc::c_char, name_length: size_t) -> *const CassValue;
    pub fn cass_aggregate_meta_name(aggregate_meta: *const CassAggregateMeta, name: *mut *const ::libc::c_char, name_length: *mut size_t) -> ();
    pub fn cass_aggregate_meta_full_name(aggregate_meta: *const CassAggregateMeta, full_name: *mut *const ::libc::c_char, full_name_length: *mut size_t) -> ();
    pub fn cass_aggregate_meta_argument_count(aggregate_meta: *const CassAggregateMeta) -> size_t;
    pub fn cass_aggregate_meta_argument_type(aggregate_meta: *const CassAggregateMeta, index: size_t) -> *const CassDataType;
    pub fn cass_aggregate_meta_return_type(aggregate_meta: *const CassAggregateMeta) -> *const CassDataType;
    pub fn cass_aggregate_meta_state_type(aggregate_meta: *const CassAggregateMeta) -> *const CassDataType;
    pub fn cass_aggregate_meta_state_func(aggregate_meta: *const CassAggregateMeta) -> *const CassFunctionMeta;
    pub fn cass_aggregate_meta_final_func(aggregate_meta: *const CassAggregateMeta) -> *const CassFunctionMeta;
    pub fn cass_aggregate_meta_init_cond(aggregate_meta: *const CassAggregateMeta) -> *const CassValue;
    pub fn cass_aggregate_meta_field_by_name(aggregate_meta: *const CassAggregateMeta, name: *const ::libc::c_char) -> *const CassValue;
    pub fn cass_aggregate_meta_field_by_name_n(aggregate_meta: *const CassAggregateMeta, name: *const ::libc::c_char, name_length: size_t) -> *const CassValue;
    pub fn cass_ssl_new() -> *mut CassSsl;
    pub fn cass_ssl_free(ssl: *mut CassSsl) -> ();
    pub fn cass_ssl_add_trusted_cert(ssl: *mut CassSsl, cert: *const ::libc::c_char) -> CassError;
    pub fn cass_ssl_add_trusted_cert_n(ssl: *mut CassSsl, cert: *const ::libc::c_char, cert_length: size_t) -> CassError;
    pub fn cass_ssl_set_verify_flags(ssl: *mut CassSsl, flags: ::libc::c_int) -> ();
    pub fn cass_ssl_set_cert(ssl: *mut CassSsl, cert: *const ::libc::c_char) -> CassError;
    pub fn cass_ssl_set_cert_n(ssl: *mut CassSsl, cert: *const ::libc::c_char, cert_length: size_t) -> CassError;
    pub fn cass_ssl_set_private_key(ssl: *mut CassSsl, key: *const ::libc::c_char, password: *const ::libc::c_char) -> CassError;
    pub fn cass_ssl_set_private_key_n(ssl: *mut CassSsl, key: *const ::libc::c_char, key_length: size_t, password: *const ::libc::c_char, password_length: size_t) -> CassError;
    pub fn cass_future_free(future: *mut CassFuture) -> ();
    pub fn cass_future_set_callback(future: *mut CassFuture, callback: CassFutureCallback, data: *mut ::libc::c_void) -> CassError;
    pub fn cass_future_ready(future: *mut CassFuture) -> cass_bool_t;
    pub fn cass_future_wait(future: *mut CassFuture) -> ();
    pub fn cass_future_wait_timed(future: *mut CassFuture, timeout_us: cass_duration_t) -> cass_bool_t;
    pub fn cass_future_get_result(future: *mut CassFuture) -> *const CassResult;
    pub fn cass_future_get_error_result(future: *mut CassFuture) -> *const CassErrorResult;
    pub fn cass_future_get_prepared(future: *mut CassFuture) -> *const CassPrepared;
    pub fn cass_future_error_code(future: *mut CassFuture) -> CassError;
    pub fn cass_future_error_message(future: *mut CassFuture, message: *mut *const ::libc::c_char, message_length: *mut size_t) -> ();
    pub fn cass_future_custom_payload_item_count(future: *mut CassFuture) -> size_t;
    pub fn cass_future_custom_payload_item(future: *mut CassFuture, index: size_t, name: *mut *const ::libc::c_char, name_length: *mut size_t, value: *mut *const cass_byte_t, value_size: *mut size_t) -> CassError;
    pub fn cass_statement_new(query: *const ::libc::c_char, parameter_count: size_t) -> *mut CassStatement;
    pub fn cass_statement_new_n(query: *const ::libc::c_char, query_length: size_t, parameter_count: size_t) -> *mut CassStatement;
    pub fn cass_statement_free(statement: *mut CassStatement) -> ();
    pub fn cass_statement_add_key_index(statement: *mut CassStatement, index: size_t) -> CassError;
    pub fn cass_statement_set_keyspace(statement: *mut CassStatement, keyspace: *const ::libc::c_char) -> CassError;
    pub fn cass_statement_set_keyspace_n(statement: *mut CassStatement, keyspace: *const ::libc::c_char, keyspace_length: size_t) -> CassError;
    pub fn cass_statement_set_consistency(statement: *mut CassStatement, consistency: CassConsistency) -> CassError;
    pub fn cass_statement_set_serial_consistency(statement: *mut CassStatement, serial_consistency: CassConsistency) -> CassError;
    pub fn cass_statement_set_paging_size(statement: *mut CassStatement, page_size: ::libc::c_int) -> CassError;
    pub fn cass_statement_set_paging_state(statement: *mut CassStatement, result: *const CassResult) -> CassError;
    pub fn cass_statement_set_paging_state_token(statement: *mut CassStatement, paging_state: *const ::libc::c_char, paging_state_size: size_t) -> CassError;
    pub fn cass_statement_set_timestamp(statement: *mut CassStatement, timestamp: cass_int64_t) -> CassError;
    pub fn cass_statement_set_retry_policy(statement: *mut CassStatement, retry_policy: *mut CassRetryPolicy) -> CassError;
    pub fn cass_statement_set_custom_payload(statement: *mut CassStatement, payload: *const CassCustomPayload) -> CassError;
    pub fn cass_statement_bind_null(statement: *mut CassStatement, index: size_t) -> CassError;
    pub fn cass_statement_bind_null_by_name(statement: *mut CassStatement, name: *const ::libc::c_char) -> CassError;
    pub fn cass_statement_bind_null_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t) -> CassError;
    pub fn cass_statement_bind_int8(statement: *mut CassStatement, index: size_t, value: cass_int8_t) -> CassError;
    pub fn cass_statement_bind_int8_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, value: cass_int8_t) -> CassError;
    pub fn cass_statement_bind_int8_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, value: cass_int8_t) -> CassError;
    pub fn cass_statement_bind_int16(statement: *mut CassStatement, index: size_t, value: cass_int16_t) -> CassError;
    pub fn cass_statement_bind_int16_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, value: cass_int16_t) -> CassError;
    pub fn cass_statement_bind_int16_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, value: cass_int16_t) -> CassError;
    pub fn cass_statement_bind_int32(statement: *mut CassStatement, index: size_t, value: cass_int32_t) -> CassError;
    pub fn cass_statement_bind_int32_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, value: cass_int32_t) -> CassError;
    pub fn cass_statement_bind_int32_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, value: cass_int32_t) -> CassError;
    pub fn cass_statement_bind_uint32(statement: *mut CassStatement, index: size_t, value: cass_uint32_t) -> CassError;
    pub fn cass_statement_bind_uint32_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, value: cass_uint32_t) -> CassError;
    pub fn cass_statement_bind_uint32_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, value: cass_uint32_t) -> CassError;
    pub fn cass_statement_bind_int64(statement: *mut CassStatement, index: size_t, value: cass_int64_t) -> CassError;
    pub fn cass_statement_bind_int64_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, value: cass_int64_t) -> CassError;
    pub fn cass_statement_bind_int64_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, value: cass_int64_t) -> CassError;
    pub fn cass_statement_bind_float(statement: *mut CassStatement, index: size_t, value: cass_float_t) -> CassError;
    pub fn cass_statement_bind_float_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, value: cass_float_t) -> CassError;
    pub fn cass_statement_bind_float_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, value: cass_float_t) -> CassError;
    pub fn cass_statement_bind_double(statement: *mut CassStatement, index: size_t, value: cass_double_t) -> CassError;
    pub fn cass_statement_bind_double_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, value: cass_double_t) -> CassError;
    pub fn cass_statement_bind_double_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, value: cass_double_t) -> CassError;
    pub fn cass_statement_bind_bool(statement: *mut CassStatement, index: size_t, value: cass_bool_t) -> CassError;
    pub fn cass_statement_bind_bool_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, value: cass_bool_t) -> CassError;
    pub fn cass_statement_bind_bool_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, value: cass_bool_t) -> CassError;
    pub fn cass_statement_bind_string(statement: *mut CassStatement, index: size_t, value: *const ::libc::c_char) -> CassError;
    pub fn cass_statement_bind_string_n(statement: *mut CassStatement, index: size_t, value: *const ::libc::c_char, value_length: size_t) -> CassError;
    pub fn cass_statement_bind_string_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, value: *const ::libc::c_char) -> CassError;
    pub fn cass_statement_bind_string_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, value: *const ::libc::c_char, value_length: size_t) -> CassError;
    pub fn cass_statement_bind_bytes(statement: *mut CassStatement, index: size_t, value: *const cass_byte_t, value_size: size_t) -> CassError;
    pub fn cass_statement_bind_bytes_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, value: *const cass_byte_t, value_size: size_t) -> CassError;
    pub fn cass_statement_bind_bytes_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, value: *const cass_byte_t, value_size: size_t) -> CassError;
    pub fn cass_statement_bind_uuid(statement: *mut CassStatement, index: size_t, value: CassUuid) -> CassError;
    pub fn cass_statement_bind_uuid_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, value: CassUuid) -> CassError;
    pub fn cass_statement_bind_uuid_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, value: CassUuid) -> CassError;
    pub fn cass_statement_bind_inet(statement: *mut CassStatement, index: size_t, value: CassInet) -> CassError;
    pub fn cass_statement_bind_inet_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, value: CassInet) -> CassError;
    pub fn cass_statement_bind_inet_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, value: CassInet) -> CassError;
    pub fn cass_statement_bind_decimal(statement: *mut CassStatement, index: size_t, varint: *const cass_byte_t, varint_size: size_t, scale: cass_int32_t) -> CassError;
    pub fn cass_statement_bind_decimal_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, varint: *const cass_byte_t, varint_size: size_t, scale: cass_int32_t) -> CassError;
    pub fn cass_statement_bind_decimal_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, varint: *const cass_byte_t, varint_size: size_t, scale: cass_int32_t) -> CassError;
    pub fn cass_statement_bind_collection(statement: *mut CassStatement, index: size_t, collection: *const CassCollection) -> CassError;
    pub fn cass_statement_bind_collection_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, collection: *const CassCollection) -> CassError;
    pub fn cass_statement_bind_collection_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, collection: *const CassCollection) -> CassError;
    pub fn cass_statement_bind_tuple(statement: *mut CassStatement, index: size_t, tuple: *const CassTuple) -> CassError;
    pub fn cass_statement_bind_tuple_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, tuple: *const CassTuple) -> CassError;
    pub fn cass_statement_bind_tuple_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, tuple: *const CassTuple) -> CassError;
    pub fn cass_statement_bind_user_type(statement: *mut CassStatement, index: size_t, user_type: *const CassUserType) -> CassError;
    pub fn cass_statement_bind_user_type_by_name(statement: *mut CassStatement, name: *const ::libc::c_char, user_type: *const CassUserType) -> CassError;
    pub fn cass_statement_bind_user_type_by_name_n(statement: *mut CassStatement, name: *const ::libc::c_char, name_length: size_t, user_type: *const CassUserType) -> CassError;
    pub fn cass_prepared_free(prepared: *const CassPrepared) -> ();
    pub fn cass_prepared_bind(prepared: *const CassPrepared) -> *mut CassStatement;
    pub fn cass_prepared_parameter_name(prepared: *const CassPrepared, index: size_t, name: *mut *const ::libc::c_char, name_length: *mut size_t) -> CassError;
    pub fn cass_prepared_parameter_data_type(prepared: *const CassPrepared, index: size_t) -> *const CassDataType;
    pub fn cass_prepared_parameter_data_type_by_name(prepared: *const CassPrepared, name: *const ::libc::c_char) -> *const CassDataType;
    pub fn cass_prepared_parameter_data_type_by_name_n(prepared: *const CassPrepared, name: *const ::libc::c_char, name_length: size_t) -> *const CassDataType;
    pub fn cass_batch_new(_type: CassBatchType) -> *mut CassBatch;
    pub fn cass_batch_free(batch: *mut CassBatch) -> ();
    pub fn cass_batch_set_consistency(batch: *mut CassBatch, consistency: CassConsistency) -> CassError;
    pub fn cass_batch_set_serial_consistency(batch: *mut CassBatch, serial_consistency: CassConsistency) -> CassError;
    pub fn cass_batch_set_timestamp(batch: *mut CassBatch, timestamp: cass_int64_t) -> CassError;
    pub fn cass_batch_set_retry_policy(batch: *mut CassBatch, retry_policy: *mut CassRetryPolicy) -> CassError;
    pub fn cass_batch_set_custom_payload(batch: *mut CassBatch, payload: *const CassCustomPayload) -> CassError;
    pub fn cass_batch_add_statement(batch: *mut CassBatch, statement: *mut CassStatement) -> CassError;
    pub fn cass_data_type_new(_type: CassValueType) -> *mut CassDataType;
    pub fn cass_data_type_new_from_existing(data_type: *const CassDataType) -> *mut CassDataType;
    pub fn cass_data_type_new_tuple(item_count: size_t) -> *mut CassDataType;
    pub fn cass_data_type_new_udt(field_count: size_t) -> *mut CassDataType;
    pub fn cass_data_type_free(data_type: *mut CassDataType) -> ();
    pub fn cass_data_type_type(data_type: *const CassDataType) -> CassValueType;
    pub fn cass_data_type_type_name(data_type: *const CassDataType, type_name: *mut *const ::libc::c_char, type_name_length: *mut size_t) -> CassError;
    pub fn cass_data_type_set_type_name(data_type: *mut CassDataType, type_name: *const ::libc::c_char) -> CassError;
    pub fn cass_data_type_set_type_name_n(data_type: *mut CassDataType, type_name: *const ::libc::c_char, type_name_length: size_t) -> CassError;
    pub fn cass_data_type_keyspace(data_type: *const CassDataType, keyspace: *mut *const ::libc::c_char, keyspace_length: *mut size_t) -> CassError;
    pub fn cass_data_type_set_keyspace(data_type: *mut CassDataType, keyspace: *const ::libc::c_char) -> CassError;
    pub fn cass_data_type_set_keyspace_n(data_type: *mut CassDataType, keyspace: *const ::libc::c_char, keyspace_length: size_t) -> CassError;
    pub fn cass_data_type_class_name(data_type: *mut CassDataType, class_name: *mut *const ::libc::c_char, class_name_length: *mut size_t) -> CassError;
    pub fn cass_data_type_set_class_name(data_type: *mut CassDataType, class_name: *const ::libc::c_char) -> CassError;
    pub fn cass_data_type_set_class_name_n(data_type: *mut CassDataType, class_name: *const ::libc::c_char, class_name_length: size_t) -> CassError;
    pub fn cass_data_sub_type_count(data_type: *const CassDataType) -> size_t;
    pub fn cass_data_type_sub_data_type(data_type: *const CassDataType, index: size_t) -> *const CassDataType;
    pub fn cass_data_type_sub_data_type_by_name(data_type: *const CassDataType, name: *const ::libc::c_char) -> *const CassDataType;
    pub fn cass_data_type_sub_data_type_by_name_n(data_type: *const CassDataType, name: *const ::libc::c_char, name_length: size_t) -> *const CassDataType;
    pub fn cass_data_type_sub_type_name(data_type: *const CassDataType, index: size_t, name: *mut *const ::libc::c_char, name_length: *mut size_t) -> CassError;
    pub fn cass_data_type_add_sub_type(data_type: *mut CassDataType, sub_data_type: *const CassDataType) -> CassError;
    pub fn cass_data_type_add_sub_type_by_name(data_type: *mut CassDataType, name: *const ::libc::c_char, sub_data_type: *const CassDataType) -> CassError;
    pub fn cass_data_type_add_sub_type_by_name_n(data_type: *mut CassDataType, name: *const ::libc::c_char, name_length: size_t, sub_data_type: *const CassDataType) -> CassError;
    pub fn cass_data_type_add_sub_value_type(data_type: *mut CassDataType, sub_value_type: CassValueType) -> CassError;
    pub fn cass_data_type_add_sub_value_type_by_name(data_type: *mut CassDataType, name: *const ::libc::c_char, sub_value_type: CassValueType) -> CassError;
    pub fn cass_data_type_add_sub_value_type_by_name_n(data_type: *mut CassDataType, name: *const ::libc::c_char, name_length: size_t, sub_value_type: CassValueType) -> CassError;
    pub fn cass_collection_new(_type: CassCollectionType, item_count: size_t) -> *mut CassCollection;
    pub fn cass_collection_new_from_data_type(data_type: *const CassDataType, item_count: size_t) -> *mut CassCollection;
    pub fn cass_collection_free(collection: *mut CassCollection) -> ();
    pub fn cass_collection_data_type(collection: *const CassCollection) -> *const CassDataType;
    pub fn cass_collection_append_int8(collection: *mut CassCollection, value: cass_int8_t) -> CassError;
    pub fn cass_collection_append_int16(collection: *mut CassCollection, value: cass_int16_t) -> CassError;
    pub fn cass_collection_append_int32(collection: *mut CassCollection, value: cass_int32_t) -> CassError;
    pub fn cass_collection_append_uint32(collection: *mut CassCollection, value: cass_uint32_t) -> CassError;
    pub fn cass_collection_append_int64(collection: *mut CassCollection, value: cass_int64_t) -> CassError;
    pub fn cass_collection_append_float(collection: *mut CassCollection, value: cass_float_t) -> CassError;
    pub fn cass_collection_append_double(collection: *mut CassCollection, value: cass_double_t) -> CassError;
    pub fn cass_collection_append_bool(collection: *mut CassCollection, value: cass_bool_t) -> CassError;
    pub fn cass_collection_append_string(collection: *mut CassCollection, value: *const ::libc::c_char) -> CassError;
    pub fn cass_collection_append_string_n(collection: *mut CassCollection, value: *const ::libc::c_char, value_length: size_t) -> CassError;
    pub fn cass_collection_append_bytes(collection: *mut CassCollection, value: *const cass_byte_t, value_size: size_t) -> CassError;
    pub fn cass_collection_append_uuid(collection: *mut CassCollection, value: CassUuid) -> CassError;
    pub fn cass_collection_append_inet(collection: *mut CassCollection, value: CassInet) -> CassError;
    pub fn cass_collection_append_decimal(collection: *mut CassCollection, varint: *const cass_byte_t, varint_size: size_t, scale: cass_int32_t) -> CassError;
    pub fn cass_collection_append_collection(collection: *mut CassCollection, value: *const CassCollection) -> CassError;
    pub fn cass_collection_append_tuple(collection: *mut CassCollection, value: *const CassTuple) -> CassError;
    pub fn cass_collection_append_user_type(collection: *mut CassCollection, value: *const CassUserType) -> CassError;
    pub fn cass_tuple_new(item_count: size_t) -> *mut CassTuple;
    pub fn cass_tuple_new_from_data_type(data_type: *const CassDataType) -> *mut CassTuple;
    pub fn cass_tuple_free(tuple: *mut CassTuple) -> ();
    pub fn cass_tuple_data_type(tuple: *const CassTuple) -> *const CassDataType;
    pub fn cass_tuple_set_null(tuple: *mut CassTuple, index: size_t) -> CassError;
    pub fn cass_tuple_set_int8(tuple: *mut CassTuple, index: size_t, value: cass_int8_t) -> CassError;
    pub fn cass_tuple_set_int16(tuple: *mut CassTuple, index: size_t, value: cass_int16_t) -> CassError;
    pub fn cass_tuple_set_int32(tuple: *mut CassTuple, index: size_t, value: cass_int32_t) -> CassError;
    pub fn cass_tuple_set_uint32(tuple: *mut CassTuple, index: size_t, value: cass_uint32_t) -> CassError;
    pub fn cass_tuple_set_int64(tuple: *mut CassTuple, index: size_t, value: cass_int64_t) -> CassError;
    pub fn cass_tuple_set_float(tuple: *mut CassTuple, index: size_t, value: cass_float_t) -> CassError;
    pub fn cass_tuple_set_double(tuple: *mut CassTuple, index: size_t, value: cass_double_t) -> CassError;
    pub fn cass_tuple_set_bool(tuple: *mut CassTuple, index: size_t, value: cass_bool_t) -> CassError;
    pub fn cass_tuple_set_string(tuple: *mut CassTuple, index: size_t, value: *const ::libc::c_char) -> CassError;
    pub fn cass_tuple_set_string_n(tuple: *mut CassTuple, index: size_t, value: *const ::libc::c_char, value_length: size_t) -> CassError;
    pub fn cass_tuple_set_bytes(tuple: *mut CassTuple, index: size_t, value: *const cass_byte_t, value_size: size_t) -> CassError;
    pub fn cass_tuple_set_uuid(tuple: *mut CassTuple, index: size_t, value: CassUuid) -> CassError;
    pub fn cass_tuple_set_inet(tuple: *mut CassTuple, index: size_t, value: CassInet) -> CassError;
    pub fn cass_tuple_set_decimal(tuple: *mut CassTuple, index: size_t, varint: *const cass_byte_t, varint_size: size_t, scale: cass_int32_t) -> CassError;
    pub fn cass_tuple_set_collection(tuple: *mut CassTuple, index: size_t, value: *const CassCollection) -> CassError;
    pub fn cass_tuple_set_tuple(tuple: *mut CassTuple, index: size_t, value: *const CassTuple) -> CassError;
    pub fn cass_tuple_set_user_type(tuple: *mut CassTuple, index: size_t, value: *const CassUserType) -> CassError;
    pub fn cass_user_type_new_from_data_type(data_type: *const CassDataType) -> *mut CassUserType;
    pub fn cass_user_type_free(user_type: *mut CassUserType) -> ();
    pub fn cass_user_type_data_type(user_type: *const CassUserType) -> *const CassDataType;
    pub fn cass_user_type_set_null(user_type: *mut CassUserType, index: size_t) -> CassError;
    pub fn cass_user_type_set_null_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char) -> CassError;
    pub fn cass_user_type_set_null_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t) -> CassError;
    pub fn cass_user_type_set_int8(user_type: *mut CassUserType, index: size_t, value: cass_int8_t) -> CassError;
    pub fn cass_user_type_set_int8_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: cass_int8_t) -> CassError;
    pub fn cass_user_type_set_int8_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: cass_int8_t) -> CassError;
    pub fn cass_user_type_set_int16(user_type: *mut CassUserType, index: size_t, value: cass_int16_t) -> CassError;
    pub fn cass_user_type_set_int16_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: cass_int16_t) -> CassError;
    pub fn cass_user_type_set_int16_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: cass_int16_t) -> CassError;
    pub fn cass_user_type_set_int32(user_type: *mut CassUserType, index: size_t, value: cass_int32_t) -> CassError;
    pub fn cass_user_type_set_int32_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: cass_int32_t) -> CassError;
    pub fn cass_user_type_set_int32_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: cass_int32_t) -> CassError;
    pub fn cass_user_type_set_uint32(user_type: *mut CassUserType, index: size_t, value: cass_uint32_t) -> CassError;
    pub fn cass_user_type_set_uint32_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: cass_uint32_t) -> CassError;
    pub fn cass_user_type_set_uint32_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: cass_uint32_t) -> CassError;
    pub fn cass_user_type_set_int64(user_type: *mut CassUserType, index: size_t, value: cass_int64_t) -> CassError;
    pub fn cass_user_type_set_int64_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: cass_int64_t) -> CassError;
    pub fn cass_user_type_set_int64_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: cass_int64_t) -> CassError;
    pub fn cass_user_type_set_float(user_type: *mut CassUserType, index: size_t, value: cass_float_t) -> CassError;
    pub fn cass_user_type_set_float_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: cass_float_t) -> CassError;
    pub fn cass_user_type_set_float_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: cass_float_t) -> CassError;
    pub fn cass_user_type_set_double(user_type: *mut CassUserType, index: size_t, value: cass_double_t) -> CassError;
    pub fn cass_user_type_set_double_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: cass_double_t) -> CassError;
    pub fn cass_user_type_set_double_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: cass_double_t) -> CassError;
    pub fn cass_user_type_set_bool(user_type: *mut CassUserType, index: size_t, value: cass_bool_t) -> CassError;
    pub fn cass_user_type_set_bool_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: cass_bool_t) -> CassError;
    pub fn cass_user_type_set_bool_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: cass_bool_t) -> CassError;
    pub fn cass_user_type_set_string(user_type: *mut CassUserType, index: size_t, value: *const ::libc::c_char) -> CassError;
    pub fn cass_user_type_set_string_n(user_type: *mut CassUserType, index: size_t, value: *const ::libc::c_char, value_length: size_t) -> CassError;
    pub fn cass_user_type_set_string_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: *const ::libc::c_char) -> CassError;
    pub fn cass_user_type_set_string_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: *const ::libc::c_char, value_length: size_t) -> CassError;
    pub fn cass_user_type_set_bytes(user_type: *mut CassUserType, index: size_t, value: *const cass_byte_t, value_size: size_t) -> CassError;
    pub fn cass_user_type_set_bytes_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: *const cass_byte_t, value_size: size_t) -> CassError;
    pub fn cass_user_type_set_bytes_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: *const cass_byte_t, value_size: size_t) -> CassError;
    pub fn cass_user_type_set_uuid(user_type: *mut CassUserType, index: size_t, value: CassUuid) -> CassError;
    pub fn cass_user_type_set_uuid_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: CassUuid) -> CassError;
    pub fn cass_user_type_set_uuid_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: CassUuid) -> CassError;
    pub fn cass_user_type_set_inet(user_type: *mut CassUserType, index: size_t, value: CassInet) -> CassError;
    pub fn cass_user_type_set_inet_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: CassInet) -> CassError;
    pub fn cass_user_type_set_inet_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: CassInet) -> CassError;
    pub fn cass_user_type_set_decimal(user_type: *mut CassUserType, index: size_t, varint: *const cass_byte_t, varint_size: size_t, scale: ::libc::c_int) -> CassError;
    pub fn cass_user_type_set_decimal_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, varint: *const cass_byte_t, varint_size: size_t, scale: ::libc::c_int) -> CassError;
    pub fn cass_user_type_set_decimal_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, varint: *const cass_byte_t, varint_size: size_t, scale: ::libc::c_int) -> CassError;
    pub fn cass_user_type_set_collection(user_type: *mut CassUserType, index: size_t, value: *const CassCollection) -> CassError;
    pub fn cass_user_type_set_collection_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: *const CassCollection) -> CassError;
    pub fn cass_user_type_set_collection_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: *const CassCollection) -> CassError;
    pub fn cass_user_type_set_tuple(user_type: *mut CassUserType, index: size_t, value: *const CassTuple) -> CassError;
    pub fn cass_user_type_set_tuple_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: *const CassTuple) -> CassError;
    pub fn cass_user_type_set_tuple_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: *const CassTuple) -> CassError;
    pub fn cass_user_type_set_user_type(user_type: *mut CassUserType, index: size_t, value: *const CassUserType) -> CassError;
    pub fn cass_user_type_set_user_type_by_name(user_type: *mut CassUserType, name: *const ::libc::c_char, value: *const CassUserType) -> CassError;
    pub fn cass_user_type_set_user_type_by_name_n(user_type: *mut CassUserType, name: *const ::libc::c_char, name_length: size_t, value: *const CassUserType) -> CassError;
    pub fn cass_result_free(result: *const CassResult) -> ();
    pub fn cass_result_row_count(result: *const CassResult) -> size_t;
    pub fn cass_result_column_count(result: *const CassResult) -> size_t;
    pub fn cass_result_column_name(result: *const CassResult, index: size_t, name: *mut *const ::libc::c_char, name_length: *mut size_t) -> CassError;
    pub fn cass_result_column_type(result: *const CassResult, index: size_t) -> CassValueType;
    pub fn cass_result_column_data_type(result: *const CassResult, index: size_t) -> *const CassDataType;
    pub fn cass_result_first_row(result: *const CassResult) -> *const CassRow;
    pub fn cass_result_has_more_pages(result: *const CassResult) -> cass_bool_t;
    pub fn cass_result_paging_state_token(result: *const CassResult, paging_state: *mut *const ::libc::c_char, paging_state_size: *mut size_t) -> CassError;
    pub fn cass_error_result_free(error_result: *const CassErrorResult) -> ();
    pub fn cass_error_result_code(error_result: *const CassErrorResult) -> CassError;
    pub fn cass_error_result_consistency(error_result: *const CassErrorResult) -> CassConsistency;
    pub fn cass_error_result_responses_received(error_result: *const CassErrorResult) -> cass_int32_t;
    pub fn cass_error_result_responses_required(error_result: *const CassErrorResult) -> cass_int32_t;
    pub fn cass_error_result_num_failures(error_result: *const CassErrorResult) -> cass_int32_t;
    pub fn cass_error_result_data_present(error_result: *const CassErrorResult) -> cass_bool_t;
    pub fn cass_error_result_write_type(error_result: *const CassErrorResult) -> CassWriteType;
    pub fn cass_error_result_keyspace(error_result: *const CassErrorResult, keyspace: *mut *const ::libc::c_char, keyspace_length: *mut size_t) -> CassError;
    pub fn cass_error_result_table(error_result: *const CassErrorResult, table: *mut *const ::libc::c_char, table_length: *mut size_t) -> CassError;
    pub fn cass_error_result_function(error_result: *const CassErrorResult, function: *mut *const ::libc::c_char, function_length: *mut size_t) -> CassError;
    pub fn cass_error_num_arg_types(error_result: *const CassErrorResult) -> size_t;
    pub fn cass_error_result_arg_type(error_result: *const CassErrorResult, index: size_t, arg_type: *mut *const ::libc::c_char, arg_type_length: *mut size_t) -> CassError;
    pub fn cass_iterator_free(iterator: *mut CassIterator) -> ();
    pub fn cass_iterator_type(iterator: *mut CassIterator) -> CassIteratorType;
    pub fn cass_iterator_from_result(result: *const CassResult) -> *mut CassIterator;
    pub fn cass_iterator_from_row(row: *const CassRow) -> *mut CassIterator;
    pub fn cass_iterator_from_collection(value: *const CassValue) -> *mut CassIterator;
    pub fn cass_iterator_from_map(value: *const CassValue) -> *mut CassIterator;
    pub fn cass_iterator_from_tuple(value: *const CassValue) -> *mut CassIterator;
    pub fn cass_iterator_fields_from_user_type(value: *const CassValue) -> *mut CassIterator;
    pub fn cass_iterator_keyspaces_from_schema_meta(schema_meta: *const CassSchemaMeta) -> *mut CassIterator;
    pub fn cass_iterator_tables_from_keyspace_meta(keyspace_meta: *const CassKeyspaceMeta) -> *mut CassIterator;
    pub fn cass_iterator_user_types_from_keyspace_meta(keyspace_meta: *const CassKeyspaceMeta) -> *mut CassIterator;
    pub fn cass_iterator_functions_from_keyspace_meta(keyspace_meta: *const CassKeyspaceMeta) -> *mut CassIterator;
    pub fn cass_iterator_aggregates_from_keyspace_meta(keyspace_meta: *const CassKeyspaceMeta) -> *mut CassIterator;
    pub fn cass_iterator_fields_from_keyspace_meta(keyspace_meta: *const CassKeyspaceMeta) -> *mut CassIterator;
    pub fn cass_iterator_columns_from_table_meta(table_meta: *const CassTableMeta) -> *mut CassIterator;
    pub fn cass_iterator_fields_from_table_meta(table_meta: *const CassTableMeta) -> *mut CassIterator;
    pub fn cass_iterator_fields_from_column_meta(column_meta: *const CassColumnMeta) -> *mut CassIterator;
    pub fn cass_iterator_fields_from_function_meta(function_meta: *const CassFunctionMeta) -> *mut CassIterator;
    pub fn cass_iterator_fields_from_aggregate_meta(aggregate_meta: *const CassAggregateMeta) -> *mut CassIterator;
    pub fn cass_iterator_next(iterator: *mut CassIterator) -> cass_bool_t;
    pub fn cass_iterator_get_row(iterator: *const CassIterator) -> *const CassRow;
    pub fn cass_iterator_get_column(iterator: *const CassIterator) -> *const CassValue;
    pub fn cass_iterator_get_value(iterator: *const CassIterator) -> *const CassValue;
    pub fn cass_iterator_get_map_key(iterator: *const CassIterator) -> *const CassValue;
    pub fn cass_iterator_get_map_value(iterator: *const CassIterator) -> *const CassValue;
    pub fn cass_iterator_get_user_type_field_name(iterator: *const CassIterator, name: *mut *const ::libc::c_char, name_length: *mut size_t) -> CassError;
    pub fn cass_iterator_get_user_type_field_value(iterator: *const CassIterator) -> *const CassValue;
    pub fn cass_iterator_get_keyspace_meta(iterator: *const CassIterator) -> *const CassKeyspaceMeta;
    pub fn cass_iterator_get_table_meta(iterator: *const CassIterator) -> *const CassTableMeta;
    pub fn cass_iterator_get_user_type(iterator: *const CassIterator) -> *const CassDataType;
    pub fn cass_iterator_get_function_meta(iterator: *const CassIterator) -> *const CassFunctionMeta;
    pub fn cass_iterator_get_aggregate_meta(iterator: *const CassIterator) -> *const CassAggregateMeta;
    pub fn cass_iterator_get_column_meta(iterator: *const CassIterator) -> *const CassColumnMeta;
    pub fn cass_iterator_get_meta_field_name(iterator: *const CassIterator, name: *mut *const ::libc::c_char, name_length: *mut size_t) -> CassError;
    pub fn cass_iterator_get_meta_field_value(iterator: *const CassIterator) -> *const CassValue;
    pub fn cass_row_get_column(row: *const CassRow, index: size_t) -> *const CassValue;
    pub fn cass_row_get_column_by_name(row: *const CassRow, name: *const ::libc::c_char) -> *const CassValue;
    pub fn cass_row_get_column_by_name_n(row: *const CassRow, name: *const ::libc::c_char, name_length: size_t) -> *const CassValue;
    pub fn cass_value_data_type(value: *const CassValue) -> *const CassDataType;
    pub fn cass_value_get_int8(value: *const CassValue, output: *mut cass_int8_t) -> CassError;
    pub fn cass_value_get_int16(value: *const CassValue, output: *mut cass_int16_t) -> CassError;
    pub fn cass_value_get_int32(value: *const CassValue, output: *mut cass_int32_t) -> CassError;
    pub fn cass_value_get_uint32(value: *const CassValue, output: *mut cass_uint32_t) -> CassError;
    pub fn cass_value_get_int64(value: *const CassValue, output: *mut cass_int64_t) -> CassError;
    pub fn cass_value_get_float(value: *const CassValue, output: *mut cass_float_t) -> CassError;
    pub fn cass_value_get_double(value: *const CassValue, output: *mut cass_double_t) -> CassError;
    pub fn cass_value_get_bool(value: *const CassValue, output: *mut cass_bool_t) -> CassError;
    pub fn cass_value_get_uuid(value: *const CassValue, output: *mut CassUuid) -> CassError;
    pub fn cass_value_get_inet(value: *const CassValue, output: *mut CassInet) -> CassError;
    pub fn cass_value_get_string(value: *const CassValue, output: *mut *const ::libc::c_char, output_size: *mut size_t) -> CassError;
    pub fn cass_value_get_bytes(value: *const CassValue, output: *mut *const cass_byte_t, output_size: *mut size_t) -> CassError;
    pub fn cass_value_get_decimal(value: *const CassValue, varint: *mut *const cass_byte_t, varint_size: *mut size_t, scale: *mut cass_int32_t) -> CassError;
    pub fn cass_value_type(value: *const CassValue) -> CassValueType;
    pub fn cass_value_is_null(value: *const CassValue) -> cass_bool_t;
    pub fn cass_value_is_collection(value: *const CassValue) -> cass_bool_t;
    pub fn cass_value_item_count(collection: *const CassValue) -> size_t;
    pub fn cass_value_primary_sub_type(collection: *const CassValue) -> CassValueType;
    pub fn cass_value_secondary_sub_type(collection: *const CassValue) -> CassValueType;
    pub fn cass_uuid_gen_new() -> *mut CassUuidGen;
    pub fn cass_uuid_gen_new_with_node(node: cass_uint64_t) -> *mut CassUuidGen;
    pub fn cass_uuid_gen_free(uuid_gen: *mut CassUuidGen) -> ();
    pub fn cass_uuid_gen_time(uuid_gen: *mut CassUuidGen, output: *mut CassUuid) -> ();
    pub fn cass_uuid_gen_random(uuid_gen: *mut CassUuidGen, output: *mut CassUuid) -> ();
    pub fn cass_uuid_gen_from_time(uuid_gen: *mut CassUuidGen, timestamp: cass_uint64_t, output: *mut CassUuid) -> ();
    pub fn cass_uuid_min_from_time(time: cass_uint64_t, output: *mut CassUuid) -> ();
    pub fn cass_uuid_max_from_time(time: cass_uint64_t, output: *mut CassUuid) -> ();
    pub fn cass_uuid_timestamp(uuid: CassUuid) -> cass_uint64_t;
    pub fn cass_uuid_version(uuid: CassUuid) -> cass_uint8_t;
    pub fn cass_uuid_string(uuid: CassUuid, output: *mut ::libc::c_char) -> ();
    pub fn cass_uuid_from_string(str: *const ::libc::c_char, output: *mut CassUuid) -> CassError;
    pub fn cass_uuid_from_string_n(str: *const ::libc::c_char, str_length: size_t, output: *mut CassUuid) -> CassError;
    pub fn cass_timestamp_gen_server_side_new() -> *mut CassTimestampGen;
    pub fn cass_timestamp_gen_monotonic_new() -> *mut CassTimestampGen;
    pub fn cass_timestamp_gen_free(timestamp_gen: *mut CassTimestampGen) -> ();
    pub fn cass_retry_policy_default_new() -> *mut CassRetryPolicy;
    pub fn cass_retry_policy_downgrading_consistency_new() -> *mut CassRetryPolicy;
    pub fn cass_retry_policy_fallthrough_new() -> *mut CassRetryPolicy;
    pub fn cass_retry_policy_logging_new(child_retry_policy: *mut CassRetryPolicy) -> *mut CassRetryPolicy;
    pub fn cass_retry_policy_free(policy: *mut CassRetryPolicy) -> ();
    pub fn cass_custom_payload_new() -> *mut CassCustomPayload;
    pub fn cass_custom_payload_free(payload: *mut CassCustomPayload) -> ();
    pub fn cass_custom_payload_set(payload: *mut CassCustomPayload, name: *const ::libc::c_char, value: *const cass_byte_t, value_size: size_t) -> ();
    pub fn cass_custom_payload_set_n(payload: *mut CassCustomPayload, name: *const ::libc::c_char, name_length: size_t, value: *const cass_byte_t, value_size: size_t) -> ();
    pub fn cass_consistency_string(consistency: CassConsistency) -> *const ::libc::c_char;
    pub fn cass_write_type_string(write_type: CassWriteType) -> *const ::libc::c_char;
    pub fn cass_error_desc(error: CassError) -> *const ::libc::c_char;
    pub fn cass_log_cleanup() -> ();
    pub fn cass_log_set_level(log_level: CassLogLevel) -> ();
    pub fn cass_log_set_callback(callback: CassLogCallback, data: *mut ::libc::c_void) -> ();
    pub fn cass_log_set_queue_size(queue_size: size_t) -> ();
    pub fn cass_log_level_string(log_level: CassLogLevel) -> *const ::libc::c_char;
    pub fn cass_inet_init_v4(address: *const cass_uint8_t) -> CassInet;
    pub fn cass_inet_init_v6(address: *const cass_uint8_t) -> CassInet;
    pub fn cass_inet_string(inet: CassInet, output: *mut ::libc::c_char) -> ();
    pub fn cass_inet_from_string(str: *const ::libc::c_char, output: *mut CassInet) -> CassError;
    pub fn cass_inet_from_string_n(str: *const ::libc::c_char, str_length: size_t, output: *mut CassInet) -> CassError;
    pub fn cass_date_from_epoch(epoch_secs: cass_int64_t) -> cass_uint32_t;
    pub fn cass_time_from_epoch(epoch_secs: cass_int64_t) -> cass_int64_t;
    pub fn cass_date_time_to_epoch(date: cass_uint32_t, time: cass_int64_t) -> cass_int64_t;
}
